from src.formats.autogenerated import rage_of_mages_1_res
from src import utils
from src import content
from collections import deque
import ctypes
import os

jn = os.path.join


def get_root():
    return "."


def get_resource_at_root(*path_parts):
    path = os.path.join(get_root(), *path_parts)
    return path


def get_config_ini():
    from configparser import ConfigParser
    cp = ConfigParser()
    config_path = get_resource_at_root("config.ini")
    assert os.path.isfile(config_path), "Can't find config.ini"
    cp.read(config_path)
    return cp


def get_rom2_path():
    """ Read path to rom2 *.res files from config.ini """
    config_ini = get_config_ini()
    rom2_path = config_ini["General"]["rom2path"]
    return rom2_path


def lazy_load_dll():
    if hasattr(lazy_load_dll, 'dll'):
        return lazy_load_dll.dll

    lazy_load_dll.dll = ctypes.CDLL(get_resource_at_root("routines.dll"))
    return lazy_load_dll.dll


def free_dll():
    ctypes.windll.kernel32.FreeLibrary.argtypes = [ctypes.wintypes.HMODULE]
    dll = lazy_load_dll.dll
    handle = dll._handle
    ctypes.windll.kernel32.FreeLibrary(handle)
    delattr(lazy_load_dll, 'dll')


def setup_sprites():
    loaded = False
    try:
        from src.formats.sprites import _sprites_cext
        content.Selector.ext_map[".256"] = _sprites_cext.ROM256CExt
        content.Selector.ext_map[".16a"] = _sprites_cext.ROM16ACExt
        loaded = True
    except:
        import traceback
        traceback.print_exc()
        print("Can't initialize cext sprite loader, using default implementation...")

    if loaded:
        return
    try:
        lazy_load_dll()
        from src.formats.sprites import _sprites_cpp
        _sprites_cpp.lazy_load_dll = lazy_load_dll
        content.Selector.ext_map[".256"] = _sprites_cpp.ROM256Cpp
        content.Selector.ext_map[".16a"] = _sprites_cpp.ROM16ACpp
    except:
        import traceback
        traceback.print_exc()
        print("Can't initialize cpp sprite loader, using default implementation...")


setup_sprites()


class ResourcesMeta(type):
    """ Allows Resources["item"] lookup as a class method."""

    def __getitem__(cls, path_parts):
        # the call is mapped to
        # res["item"] -> path_parts == "item"
        # res["item", "subitem"] -> path_parts == ("item", "subitem")
        if type(path_parts) is str:
            path_parts = [path_parts]

        parts = []
        for part in path_parts:
            # "dir\\file -> (dir, file)"
            parts += utils.split_path(part)

        return cls.get(*parts)


def get_selector():
    # inject in main
    # resources.get_selector = content.Selector
    # raise Exception("Not initialized")
    return content.Selector


class Resources(object, metaclass=ResourcesMeta):
    """
        Access resource from resource file (.res) by path.
        First part of the path denotes name of the resource file (without extension).
        Rest is path to the file inside the (.res).

        Example:
        >>> ogre_256_rec = Resources["graphics", "units", "monsters", "ogre", "sprites.256"]
        # ogre_256_rec is proxy class ResourceRecordFile
        >>> ogre_256 = ogre_256_rec.content
        # ogre_256 is instance of ROM256
        """

    res_cache = {}

    mapping = {
        "data.bin": ("world", "data", "data.bin"),
        "itemname.bin": ("world", "data", "itemname.bin"),
        "structures.reg": ("graphics", "structures", "structures.reg"),
        "objects.reg": ("graphics", "objects", "objects.reg"),
        "units.reg": ("graphics", "units", "units.reg"),
        "projectiles.reg": ("graphics", "projectiles", "projectiles.reg"),
    }

    @classmethod
    def get(cls, *path_parts):
        parts = list(path_parts)
        res_name, parts = parts[0], parts[1:]

        if res_name not in cls.res_cache:
            cls.res_cache[res_name] = Resource.from_resource_name(res_name)
        res = cls.res_cache[res_name]
        return res.find_file(*parts) if parts else res

    @classmethod
    def special(cls, key):
        """
            Sugar-function to access often-sought resources and registries:
            data.bin, structures.reg, objects.reg, units.reg, etc.

            Example:
                Resources.special("data.bin")
        """
        return cls[cls.mapping[key]]

    @classmethod
    def from_file(cls, *path_parts):
        root = get_root()
        path = os.path.join(root, *path_parts)
        resource_name = os.path.split(path)[1]
        return get_selector()(path, resource_name, "from_file")


class ResourceRecordFile(rage_of_mages_1_res.RageOfMages1Res.ResourceRecordFile):

    @property
    def content(self):
        # try to guess what type of resource it is and return it's instance
        return get_selector()(self.bytes, self.name)


rage_of_mages_1_res.RageOfMages1Res.ResourceRecordFile = ResourceRecordFile


class Resource(rage_of_mages_1_res.RageOfMages1Res):
    _cache = {}

    @classmethod
    def from_resource_name(cls, name):
        resources_path = get_rom2_path()
        resource_path = jn(resources_path, f"{name}.res")
        resource = cls.from_file(resource_path)
        return resource

    def find_file(self, *path_parts):
        """ Access some file from inside the resource by path. """
        resource_path = jn(*path_parts)
        path_parts = tuple(reversed(path_parts))
        node_list = self.nodes.header

        # cache intermediate points
        cache_key = ""
        while len(path_parts) > 1:
            part = path_parts[-1].lower()
            path_parts = path_parts[:-1]
            cache_key = os.path.join(cache_key, part)
            if cache_key in self._cache:
                node_list = self._cache[cache_key]
                continue
            for header in node_list:
                if header.record.name.lower() == part and header.rec_type == self.EResourceRecordType.directory:
                    node_list = header.record.nodes.header
                    self._cache[cache_key] = node_list

        part = path_parts[0]
        for header in node_list:
            if header.record.name.lower() == part:
                if header.rec_type == self.EResourceRecordType.directory:
                    return header.record.nodes.header
                elif header.rec_type == self.EResourceRecordType.file:
                    return header.record
        raise KeyError("%s not found" % resource_path)

    def __getitem__(self, path_parts):

        if type(path_parts) is str:
            path_parts = [path_parts]

        parts = []
        for part in path_parts:
            parts += utils.split_path(part)

        return self.find_file(*parts)

    def walk(self, path=""):
        q = deque([(self.nodes.header, path)])
        while q:
            node_header_nodes, path = q.popleft()
            for header in node_header_nodes:
                if header.rec_type == self.EResourceRecordType.directory:
                    q.append((header.record.nodes.header, jn(path, header.record.name)))
                else:
                    yield path, header.record

    def list_files(self):
        for path, file in self.walk():
            yield os.path.join(path, file.name)

    def unpack_res(self, out_path):
        for path, file in self.walk():
            file_path = jn(out_path, path, file.name)
            os.makedirs(file_path, exist_ok=True)
            with open(file_path, 'wb') as f:
                f.write(file.bytes)


def custom_repr_header(self):
    addr = hex(id(self))
    return f"Header of hdr.record <{self.record}> at {addr}"


def custom_repr_file(self):
    attrs = f"{self.name}"
    addr = hex(id(self))
    return f"{attrs}, {type(self)} at {addr}"


def custom_repr_directory(self):
    attrs = f"{self.name}"
    addr = hex(id(self))
    return f"{attrs}, {type(self)} at {addr}"


rage_of_mages_1_res.RageOfMages1Res.ResourceHeader.__repr__ = custom_repr_header
rage_of_mages_1_res.RageOfMages1Res.ResourceRecordFile.__repr__ = custom_repr_file
rage_of_mages_1_res.RageOfMages1Res.ResourceRecordDirectory.__repr__ = custom_repr_file
