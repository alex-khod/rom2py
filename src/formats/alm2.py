from src.formats.autogenerated import rage_of_mages_2_alm

from functools import lru_cache

RageOfMages2Alm = rage_of_mages_2_alm.RageOfMages2Alm

class Alm2(RageOfMages2Alm):

    @property
    def section(self):
        return self.SectionKindE

    @property
    def width(self):
        return self.general_map_info.width

    @property
    def height(self):
        return self.general_map_info.width

    @property
    def heights(self):
        if hasattr(self, '_heights'):
            return self._heights
        w, h = self.width, self.height
        heights = self["heights"].body.heights
        _heights = [heights[j * w:(j + 1) * w] + [0] for j in range(h)] + [[0] * (w + 1)]
        self._heights = _heights
        return _heights

    def heights_for_tile(self, tile_x, tile_y):
        """
        Value in heights[y][x] corresponds to height of left-top (↖) corner of tile [y][x].
        Return heights of tile corners in order ↖ ↗ ↘ ↙.
        """
        heights = self.heights
        y, x = tile_y, tile_x

        h00 = heights[y + 0][x + 0]
        h10 = heights[y + 0][x + 1]
        h11 = heights[y + 1][x + 1]
        h01 = heights[y + 1][x + 0]

        return [h00, h10, h11, h01]

    TERRAIN_WIDTH_PER_ID = 16

    def tile_id_to_tilecoords(self, tile_id):
        # terrain_id = (tile_id >> 8)
        # column_id = (tile_id >> 4) & 0xF
        # stripe_id = terrain_id * self.TERRAIN_WIDTH_PER_ID + column_id
        # row_id = min(tile_id & 0xF, 13 if terrain_id != 2 else 7)

        tilemap_x = tile_id >> 4  # aka stripe_id
        tilemap_y = tile_id & 0xF  # aka row_id
        return tilemap_x, tilemap_y

    @property
    def tilecoords(self):
        """
        Terrain tiles are divided into 32px wide stripes of varying length, that reside in "graphics.res / terrain /".
        Stripes have names in format tileX-YY, where X is terrain id=[0..3], and YY is column id=[0..15].
        Terrain

        :return: list of tilecoords[tilemap_y][tilemap_x]
        """

        if hasattr(self, '_tilecoords'):
            return self._tilecoords

        _tilecoords = [[None] * self.width for _ in range(self.height)]
        for idx, tile in enumerate(self["tiles"].body.tiles):
            x, y = idx % self.width, idx // self.width
            _tilecoords[y][x] = self.tile_id_to_tilecoords(tile.tile_id)

        self._tilecoords = _tilecoords
        return _tilecoords

    def __getitem__(self, kind):
        if isinstance(kind, str):
            return next(filter(lambda x: x.header.section_kind == self.section[kind], self.sections))
        return next(filter(lambda x: x.header.section_kind == kind, self.sections))


def instance_str(instance):
    """ TriggerInstanceEntry to string """
    args = zip(instance.argument_names, instance.argument_types, instance.argument_values)
    args = list(filter(lambda x: x[1], args))
    args = [(name, atype.name, val) for name, atype, val in args]
    rmt = '' if not instance.run_once_flag else ' (can only be run once)'
    if not isinstance(instance.type, Alm2.InstanceType) and not isinstance(instance.type, Alm2.CheckType):
        # type = 29, tile_spell_duration
        raise TypeError(f"Unknown check or instance of type {instance.type} for {instance.name}")

    return '%s : %s ->' % (instance.name, instance.type.name) + ','.join(['%s : %s = %s' % arg for arg in args]) + rmt


def check_str(check):
    """ TriggerEntry to string """
    if not isinstance(check.type, Alm2.CheckType):
        # type = 14, get_sack
        raise TypeError(f"Unknown check of type {check.type} for {check.name}")
    if check.type == check.type.__class__.constant:
        return '%d (constant, named %s)' % (check.argument_values[0], check.name)
    return instance_str(check)


ops = ['==', '!=', '>', '<', '>=', '<=']
check_op_map = dict(zip(RageOfMages2Alm.CheckOperator, ops))


def trigger_str(trigger):
    checks_by_id = trigger._parent.checks_by_id
    instances_by_id = trigger._parent.instances_by_id
    res = []
    rmt = '' if trigger.run_once_flag else ', can be run multiple times'
    res += ['trigger \"%s\"%s. Is as follows:' % (trigger.name, rmt)]
    for i in range(3):
        left, right = i * 2, i * 2 + 1
        check1_id = trigger.check_identifiers[left]
        check2_id = trigger.check_identifiers[right]
        if not (check1_id and check2_id):
            continue
        try:
            check1 = checks_by_id[check1_id]
            check2 = checks_by_id[check2_id]
        except KeyError:
            print(f'Warning: bugged trigger \"{trigger.name}\" with checks id={check1_id} or id={check2_id}')
            res += ['and'] if i > 0 else ['if']
            res += ['[idk, bugged condition]']
            continue
        check_op = trigger.check_operators[i]
        check_op_name = check_op_map[check_op]
        res += ['and'] if i > 0 else ['if']
        res += [check1, '%s (%s)' % (check_op.name, check_op_name), check2]

    res += ['\nthen']
    iids = list(filter(lambda x: x, trigger.instance_identifiers))
    for i, iid in enumerate(iids):
        res += ['%d. %s' % (i + 1, instances_by_id[iid])]
    if not iids:
        res += ['[zero instances]']
    return '\n'.join([str(s) for s in res])


def unit_repr(self):
    return f"<UnitEntry {self.type_id} at x={self.x >> 8}, y={self.y >> 8}>"


RageOfMages2Alm.UnitEntry.__repr__ = unit_repr


class TriggersSec(RageOfMages2Alm.TriggersSec):

    def _read(self):
        super()._read()
        self.checks_by_id = {check.id: check for check in self.checks}
        self.instances_by_id = {instance.id: instance for instance in self.instances}


RageOfMages2Alm.CheckEntry.__str__ = check_str
RageOfMages2Alm.InstanceEntry.__str__ = instance_str
RageOfMages2Alm.TriggerEntry.__str__ = trigger_str
RageOfMages2Alm.TriggersSec = TriggersSec
