import functools
from typing import Tuple

from pyglet.math import Vec2, Vec3

from src.formats.autogenerated import rage_of_mages_2_alm

from src.utils import bisect_left

RageOfMages2Alm = rage_of_mages_2_alm.RageOfMages2Alm
TILE_SIZE = 32


def cached_property(method):
    # don't use
    # placeholder for something if lru_cache isn't enough
    def _decorator(self):
        if not hasattr(self, "_cache"):
            self._cache = {}
        funcname = method.__name__
        if funcname in self._cache:
            return self._cache[funcname]
        result = method(self)
        self._cache[funcname] = result
        return self._cache[funcname]

    return property(functools.lru_cache(maxsize=1)(method))


class HeightMap:
    def __init__(self, heights, width, height):
        self._flat_heights = heights
        self._width = width
        self._height = height

    @cached_property
    def heights(self):
        w, h = self._width, self._height
        flat_heights = self._flat_heights
        _heights = [flat_heights[j * w:(j + 1) * w] + [0] for j in range(h)]
        padding_row = [[0] * (w + 1)]
        _heights += padding_row
        return _heights

    @cached_property
    def heights_columns(self):
        w, h = self._width, self._height
        heights = self.heights
        return tuple(tuple(heights[y][x] for y in range(h)) for x in range(w))

    def heights_column_at(self, tile_x):
        return self.heights_columns[tile_x]

    @cached_property
    def ys_columns(self):
        w, h = self._width, self._height
        heights = self.heights
        ys_columns = tuple(tuple(y * TILE_SIZE - heights[y][x] for y in range(h)) for x in range(w))
        return ys_columns

    def ys_column_at(self, tile_x):
        return self.ys_columns[tile_x]

    def world_xy_to_tile_xy(self, x, y):
        """
        # These are tiles 1 and 2, tile 1 being above tile 2
         /| - Upper bound of tile 1 '/'
        | |
        |/| - Bottom bound of tile 1. XY Point placed to the left of the '/' should yield upper tile and vice versa.
        | |
        |/  - Bottom bound of tile 2.
        """
        tile_x = int(x) // TILE_SIZE
        assure_right_side_height = 1
        tile_x = min(tile_x, self._width - 1 - assure_right_side_height)
        # find tile row of upper bound to the sides
        ys_to_left = self.ys_column_at(tile_x)
        tile_y_to_left = bisect_left(ys_to_left, y)
        ys_to_right = self.ys_column_at(tile_x + 1)
        tile_y_to_right = bisect_left(ys_to_right, y)

        # tile_y of upper bound
        assure_bottom_side_bound = 1
        tile_y_to_left = min(tile_y_to_left, self._height - 1 - assure_bottom_side_bound)
        tile_y_to_right = min(tile_y_to_right, self._height - 1 - assure_bottom_side_bound)
        tile_y = min(tile_y_to_left, tile_y_to_right)

        def y_higher_than_bound(tile_y):
            y_left, y_right = ys_to_left[tile_y + 1], ys_to_right[tile_y + 1]
            x_in_tile = x % TILE_SIZE
            bound_y_at_x = y_left + (y_right - y_left) / TILE_SIZE * x_in_tile
            # if y > bound_y_at_x, the (x, y) points to the bottom cell
            return y > bound_y_at_x

        while ((tile_y < tile_y_to_left) or (tile_y < tile_y_to_right)) and y_higher_than_bound(tile_y):
            tile_y += 1

        return tile_x, tile_y, tile_y_to_left, tile_y_to_right

    def tile_corner_heights_at(self, tile_x, tile_y):
        """
        Value in heights[y][x] corresponds to height of left-top (↖) corner of tile [y][x].
        Return heights of tile corners in order ↖ ↗ ↘ ↙.
        """
        heights = self.heights
        y, x = int(tile_y), int(tile_x)

        h00 = heights[y + 0][x + 0]
        h10 = heights[y + 0][x + 1]
        h11 = heights[y + 1][x + 1]
        h01 = heights[y + 1][x + 0]

        return [h00, h10, h11, h01]

    def tile_avg_heights_at(self, tile_xy: Vec2):
        # to support non-integer txy
        # tile_xy = round(tile_xy)
        heights = self.tile_corner_heights_at(tile_xy.x, tile_xy.y)
        avg = sum(heights) / len(heights)
        return avg

    def tile_center_at(self, tile_xy: Vec2):
        h = self.tile_avg_heights_at(tile_xy)
        xy = tile_xy * TILE_SIZE + Vec2(TILE_SIZE // 2, TILE_SIZE // 2 - h)
        return xy

    def xyh_from_tile_xy(self, tile_xy: Vec2) -> Tuple[Vec2, float]:
        xy = tile_xy * TILE_SIZE
        h = self.tile_avg_heights_at(tile_xy)
        return xy, h

    def xy_from_tile_xy(self, tile_xy: Vec2) -> Vec2:
        return tile_xy * TILE_SIZE

    def draw_xy_from_tile_xy(self, tile_xy: Vec2) -> Vec2:
        avg_heights = self.tile_avg_heights_at(tile_xy)
        return tile_xy * TILE_SIZE + Vec2(0, 0 - avg_heights)


class Alm2(RageOfMages2Alm, HeightMap):
    def __init__(self, _io, _parent=None, _root=None):
        RageOfMages2Alm.__init__(self, _io, _parent, _root)
        flat_heights = self["heights"].body.heights
        HeightMap.__init__(self, flat_heights, self.width, self.height)

    @property
    def section(self):
        return self.SectionKindE

    @property
    def width(self):
        return self.general.width

    @property
    def height(self):
        return self.general.height

    TERRAIN_WIDTH_PER_ID = 16

    def tile_id_to_tilecoords(self, tile_id):
        # terrain_id = (tile_id >> 8)
        # column_id = (tile_id >> 4) & 0xF
        # column_id = terrain_id * self.TERRAIN_WIDTH_PER_ID + column_id
        # row_id = min(tile_id & 0xF, 13 if terrain_id != 2 else 7)

        tilemap_x = tile_id >> 4  # column_id
        tilemap_y = tile_id & 0xF  # row_id
        return tilemap_x, tilemap_y

    @cached_property
    def tilecoords(self):
        """
        Terrain tiles are divided into 32px wide columns of varying length, that reside in "graphics.res / terrain /".
        columns have names in format tileX-YY, where X is terrain id=[0..3], and YY is column id=[0..15].
        Terrain

        :return: list of tilecoords[height][width]
        """
        _tilecoords = [[None] * self.width for _ in range(self.height)]
        for idx, tile in enumerate(self["tiles"].body.tiles):
            x, y = idx % self.width, idx // self.width
            _tilecoords[y][x] = self.tile_id_to_tilecoords(tile.tile_id)

        return _tilecoords

    def __getitem__(self, kind) -> RageOfMages2Alm.AlmSection:
        if isinstance(kind, str):
            return next(filter(lambda x: x.header.section_kind == self.section[kind], self.sections))
        return next(filter(lambda x: x.header.section_kind == kind, self.sections))


def instance_str(instance):
    """ TriggerInstanceEntry to string """
    args = zip(instance.argument_names, instance.argument_types, instance.argument_values)
    args = list(filter(lambda x: x[1], args))
    args = [(name, atype.name, val) for name, atype, val in args]
    rmt = '' if not instance.run_once_flag else ' (can only be run once)'
    if not isinstance(instance.type, Alm2.InstanceType) and not isinstance(instance.type, Alm2.CheckType):
        # type = 29, tile_spell_duration
        raise TypeError(f"Unknown check or instance of type {instance.type} for {instance.name}")

    return '%s : %s ->' % (instance.name, instance.type.name) + ','.join(['%s : %s = %s' % arg for arg in args]) + rmt


def check_str(check):
    """ TriggerEntry to string """
    if not isinstance(check.type, Alm2.CheckType):
        # type = 14, get_sack
        raise TypeError(f"Unknown check of type {check.type} for {check.name}")
    if check.type == check.type.__class__.constant:
        return '%d (constant, named %s)' % (check.argument_values[0], check.name)
    return instance_str(check)


ops = ['==', '!=', '>', '<', '>=', '<=']
check_op_map = dict(zip(RageOfMages2Alm.CheckOperator, ops))


def trigger_str(trigger):
    checks_by_id = trigger._parent.checks_by_id
    instances_by_id = trigger._parent.instances_by_id
    res = []
    rmt = '' if trigger.run_once_flag else ', can be run multiple times'
    res += ['trigger \"%s\"%s. Is as follows:' % (trigger.name, rmt)]
    for i in range(3):
        left, right = i * 2, i * 2 + 1
        check1_id = trigger.check_ids[left]
        check2_id = trigger.check_ids[right]
        if not (check1_id and check2_id):
            continue
        try:
            check1 = checks_by_id[check1_id]
            check2 = checks_by_id[check2_id]
        except KeyError:
            print(f'Warning: bugged trigger \"{trigger.name}\" with checks id={check1_id} or id={check2_id}')
            res += ['and'] if i > 0 else ['if']
            res += ['[idk, bugged condition]']
            continue
        check_op = RageOfMages2Alm.CheckOperator(trigger.check_operators[i])
        check_op_name = check_op_map[check_op]
        res += ['and'] if i > 0 else ['if']
        res += [check1, '%s (%s)' % (check_op.name, check_op_name), check2]

    res += ['\nthen']
    iids = list(filter(lambda x: x, trigger.instance_ids))
    for i, iid in enumerate(iids):
        res += ['%d. %s' % (i + 1, instances_by_id[iid])]
    if not iids:
        res += ['[zero instances]']
    return '\n'.join([str(s) for s in res])


def unit_repr(self):
    return f"<UnitEntry {self.type_id} at x={self.x >> 8}, y={self.y >> 8}>"


RageOfMages2Alm.UnitEntry.__repr__ = unit_repr


class TriggersSec(RageOfMages2Alm.TriggersSec):

    def _read(self):
        super()._read()
        self.checks_by_id = {check.id: check for check in self.checks}
        self.instances_by_id = {instance.id: instance for instance in self.instances}


RageOfMages2Alm.CheckEntry.__str__ = check_str
RageOfMages2Alm.InstanceEntry.__str__ = instance_str
RageOfMages2Alm.TriggerEntry.__str__ = trigger_str
RageOfMages2Alm.TriggersSec = TriggersSec
