from src.formats.autogenerated import rage_of_mages_2_alm

from functools import lru_cache
from src.utils import bisect_left

RageOfMages2Alm = rage_of_mages_2_alm.RageOfMages2Alm
TILE_SIZE = 32


class Alm2(RageOfMages2Alm):
    _heights = None
    _heights_columns = None
    _ys_columns = None

    @property
    def section(self):
        return self.SectionKindE

    @property
    def width(self):
        return self.general_map_info.width

    @property
    def height(self):
        return self.general_map_info.width

    @property
    def heights(self):
        if self._heights is not None:
            return self._heights
        w, h = self.width, self.height
        raw_heights = self["heights"].body.heights
        _heights = [raw_heights[j * w:(j + 1) * w] + [0] for j in range(h)]
        padding_row = [[0] * (w + 1)]
        _heights += padding_row
        self._heights = _heights
        return _heights

    def heights_column_at(self, tile_x):
        if self._heights_columns is not None:
            return self._heights_columns[tile_x]

        w, h = self.width, self.height

        heights = self.heights
        self._heights_columns = tuple(tuple(heights[y][x] for y in range(h)) for x in range(w))
        return self._heights_columns[tile_x]

    def ys_column_at(self, tile_x):
        if self._ys_columns is not None:
            return self._ys_columns[tile_x]

        w, h = self.width, self.height

        heights = self.heights
        self._ys_columns = tuple(tuple(y * TILE_SIZE - heights[y][x] for y in range(h)) for x in range(w))
        return self._ys_columns[tile_x]

    def world_xy_to_tile_xy(self, x, y):
        """
        # These are tiles 1 and 2, tile 1 being above tile 2
         /| - Upper bound of tile 1 '/'
        | |
        |/| - Bottom bound of tile 1. XY Point placed to the left of the '/' should yield upper tile and vice versa.
        | |
        |/  - Bottom bound of tile 2.
        """
        tile_x = int(x) // TILE_SIZE
        assure_right_side_height = 1
        tile_x = min(tile_x, self.width - 1 - assure_right_side_height)
        ys_to_left = self.ys_column_at(tile_x)
        tile_y_to_left = bisect_left(ys_to_left, y)
        ys_to_right = self.ys_column_at(tile_x + 1)
        tile_y_to_right = bisect_left(ys_to_right, y)

        # tile_y of upper bound
        assure_bottom_side_bound = 1
        tile_y = min(tile_y_to_left, tile_y_to_right, self.height - 1 - assure_bottom_side_bound)
        # coordinates of bottom bound
        y_left, y_right = ys_to_left[tile_y + 1], ys_to_right[tile_y + 1]
        x_in_tile = x % TILE_SIZE
        bound_y_at_x = y_left + (y_right - y_left) / TILE_SIZE * x_in_tile
        # if y > bound_y_at_x, the (x, y) points to the bottom cell
        if y > bound_y_at_x:
            tile_y += 1
        return tile_x, tile_y

    def tile_corner_heights_at(self, tile_x, tile_y):
        """
        Value in heights[y][x] corresponds to height of left-top (↖) corner of tile [y][x].
        Return heights of tile corners in order ↖ ↗ ↘ ↙.
        """
        heights = self.heights
        y, x = tile_y, tile_x

        h00 = heights[y + 0][x + 0]
        h10 = heights[y + 0][x + 1]
        h11 = heights[y + 1][x + 1]
        h01 = heights[y + 1][x + 0]

        return [h00, h10, h11, h01]

    TERRAIN_WIDTH_PER_ID = 16

    def tile_id_to_tilecoords(self, tile_id):
        # terrain_id = (tile_id >> 8)
        # column_id = (tile_id >> 4) & 0xF
        # column_id = terrain_id * self.TERRAIN_WIDTH_PER_ID + column_id
        # row_id = min(tile_id & 0xF, 13 if terrain_id != 2 else 7)

        tilemap_x = tile_id >> 4  # column_id
        tilemap_y = tile_id & 0xF  # row_id
        return tilemap_x, tilemap_y

    @property
    def tilecoords(self):
        """
        Terrain tiles are divided into 32px wide columns of varying length, that reside in "graphics.res / terrain /".
        columns have names in format tileX-YY, where X is terrain id=[0..3], and YY is column id=[0..15].
        Terrain

        :return: list of tilecoords[tilemap_y][tilemap_x]
        """

        if hasattr(self, '_tilecoords'):
            return self._tilecoords

        _tilecoords = [[None] * self.width for _ in range(self.height)]
        for idx, tile in enumerate(self["tiles"].body.tiles):
            x, y = idx % self.width, idx // self.width
            _tilecoords[y][x] = self.tile_id_to_tilecoords(tile.tile_id)

        self._tilecoords = _tilecoords
        return _tilecoords

    def __getitem__(self, kind):
        if isinstance(kind, str):
            return next(filter(lambda x: x.header.section_kind == self.section[kind], self.sections))
        return next(filter(lambda x: x.header.section_kind == kind, self.sections))


def instance_str(instance):
    """ TriggerInstanceEntry to string """
    args = zip(instance.argument_names, instance.argument_types, instance.argument_values)
    args = list(filter(lambda x: x[1], args))
    args = [(name, atype.name, val) for name, atype, val in args]
    rmt = '' if not instance.run_once_flag else ' (can only be run once)'
    if not isinstance(instance.type, Alm2.InstanceType) and not isinstance(instance.type, Alm2.CheckType):
        # type = 29, tile_spell_duration
        raise TypeError(f"Unknown check or instance of type {instance.type} for {instance.name}")

    return '%s : %s ->' % (instance.name, instance.type.name) + ','.join(['%s : %s = %s' % arg for arg in args]) + rmt


def check_str(check):
    """ TriggerEntry to string """
    if not isinstance(check.type, Alm2.CheckType):
        # type = 14, get_sack
        raise TypeError(f"Unknown check of type {check.type} for {check.name}")
    if check.type == check.type.__class__.constant:
        return '%d (constant, named %s)' % (check.argument_values[0], check.name)
    return instance_str(check)


ops = ['==', '!=', '>', '<', '>=', '<=']
check_op_map = dict(zip(RageOfMages2Alm.CheckOperator, ops))


def trigger_str(trigger):
    checks_by_id = trigger._parent.checks_by_id
    instances_by_id = trigger._parent.instances_by_id
    res = []
    rmt = '' if trigger.run_once_flag else ', can be run multiple times'
    res += ['trigger \"%s\"%s. Is as follows:' % (trigger.name, rmt)]
    for i in range(3):
        left, right = i * 2, i * 2 + 1
        check1_id = trigger.check_identifiers[left]
        check2_id = trigger.check_identifiers[right]
        if not (check1_id and check2_id):
            continue
        try:
            check1 = checks_by_id[check1_id]
            check2 = checks_by_id[check2_id]
        except KeyError:
            print(f'Warning: bugged trigger \"{trigger.name}\" with checks id={check1_id} or id={check2_id}')
            res += ['and'] if i > 0 else ['if']
            res += ['[idk, bugged condition]']
            continue
        check_op = trigger.check_operators[i]
        check_op_name = check_op_map[check_op]
        res += ['and'] if i > 0 else ['if']
        res += [check1, '%s (%s)' % (check_op.name, check_op_name), check2]

    res += ['\nthen']
    iids = list(filter(lambda x: x, trigger.instance_identifiers))
    for i, iid in enumerate(iids):
        res += ['%d. %s' % (i + 1, instances_by_id[iid])]
    if not iids:
        res += ['[zero instances]']
    return '\n'.join([str(s) for s in res])


def unit_repr(self):
    return f"<UnitEntry {self.type_id} at x={self.x >> 8}, y={self.y >> 8}>"


RageOfMages2Alm.UnitEntry.__repr__ = unit_repr


class TriggersSec(RageOfMages2Alm.TriggersSec):

    def _read(self):
        super()._read()
        self.checks_by_id = {check.id: check for check in self.checks}
        self.instances_by_id = {instance.id: instance for instance in self.instances}


RageOfMages2Alm.CheckEntry.__str__ = check_str
RageOfMages2Alm.InstanceEntry.__str__ = instance_str
RageOfMages2Alm.TriggerEntry.__str__ = trigger_str
RageOfMages2Alm.TriggersSec = TriggersSec
